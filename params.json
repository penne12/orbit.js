{"name":"Orbit.js","tagline":"Simplify the data layer in your client-side applications.","body":"# Orbit.js [![Build Status](https://secure.travis-ci.org/orbitjs/orbit.js.png?branch=master)](http://travis-ci.org/orbitjs/orbit.js) [![Join the chat at https://gitter.im/orbitjs/orbit.js](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/orbitjs/orbit.js?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n\r\nOrbit is a standalone library for coordinating access to data sources\r\nand keeping their contents synchronized.\r\n\r\nOrbit provides a foundation for building advanced features in client-side\r\napplications such as offline operation, maintenance and synchronization of local\r\ncaches, undo / redo stacks and ad hoc editing contexts.\r\n\r\nOrbit relies heavily on promises, events and low-level transforms.\r\n\r\n## Goals\r\n\r\n* Support any number of different data sources in an application and\r\n  provide access to them through common interfaces.\r\n\r\n* Allow for the fulfillment of requests by different sources, including\r\n  the ability to specify priority and fallback plans.\r\n\r\n* Allow records to simultaneously exist in different states across sources.\r\n\r\n* Coordinate transformations across sources. Handle merges automatically\r\n  where possible but allow for complete custom control.\r\n\r\n* Allow for blocking and non-blocking transformations.\r\n\r\n* Allow for synchronous and asynchronous requests.\r\n\r\n* Support transactions and undo/redo by tracking inverses of operations.\r\n\r\n* Work with plain JavaScript objects.\r\n\r\n## Dependencies\r\n\r\nOrbit.js has no specific external run-time dependencies, but it must be used in an\r\nenvironment that includes an implementation of the [Promises/A+](http://promises-aplus.github.io/promises-spec/). If you wish to support legacy browsers, you will need to include a library\r\nsuch as [RSVP](https://github.com/tildeio/rsvp.js).\r\n\r\n## Installation\r\n\r\nOrbit can be installed with [Bower](http://bower.io):\r\n\r\n```\r\nbower install orbit.js\r\n```\r\n\r\n[A separate shim repo](https://github.com/orbitjs/orbit-builds) is\r\nmaintained for builds.\r\n\r\n## Configuration\r\n\r\nYou'll need to configure Orbit to recognize any applicable dependencies.\r\n\r\nOrbit defaults to using the global `Promise` constructor, if it exists. If your environment\r\ndoes not implement Promises, or if you wish to use another Promise implementation, configure\r\nyour promise library's `Promise` constructor as follows:\r\n\r\n```javascript\r\nOrbit.Promise = RSVP.Promise;\r\n```\r\n\r\nIf you're using an Orbit source that relies on an `ajax` method (such as\r\n`JSONAPISource`), configure it as follows:\r\n\r\n```javascript\r\nOrbit.ajax = jQuery.ajax;\r\n```\r\n\r\nOther sources may have other configuration requirements.\r\n\r\n## How does Orbit work?\r\n\r\nOrbit requires that every data source support one or more common interfaces.\r\nThese interfaces define how data can be both *accessed* and *transformed*.\r\n\r\nThe methods for accessing and transforming data return promises. These promises\r\nmight be fulfilled synchronously or asynchronously. Once fulfilled, events\r\nare triggered to indicate success or failure. Any event listeners can engage\r\nwith an event by returning a promise. In this way, multiple data sources can be\r\ninvolved in a single action.\r\n\r\nStandard connectors are supplied for listening to events on a data source and\r\ncalling corresponding actions on a target. These connectors can be blocking\r\n(i.e. they don't resolve until all associated actions are resolved) or\r\nnon-blocking (i.e. associated actions are resolved in the background without\r\nblocking the flow of the application). Connectors can be used to enable\r\nuni or bi-directional flow of data between sources.\r\n\r\n## Orbit Common Library\r\n\r\nThe Orbit Common library (namespaced `OC` by default) contains a set of\r\ncompatible data sources, currently including: an in-memory cache, a local\r\nstorage source, and a source for accessing [JSON API](http://jsonapi.org/)\r\ncompliant APIs with AJAX.\r\n\r\nYou can define your own data sources that will work with Orbit as long as they\r\nsupport Orbit's interfaces. You can either make sources compliant with the\r\nOrbit Common library or use Orbit's base interfaces to create an independent\r\ncollection of compatible sources.\r\n\r\n## Simple Example\r\n\r\n```javascript\r\n\r\n  // Create data sources with a common schema\r\n  var schema = new OC.Schema({\r\n    modelDefaults: {\r\n      keys: {\r\n        __id: { primaryKey: true, defaultValue: Orbit.uuid }\r\n      },\r\n    },\r\n    models: {\r\n      planet: {\r\n        attributes: {\r\n          name: {type: 'string'},\r\n          classification: {type: 'string'}\r\n        }\r\n      }\r\n    }\r\n  });\r\n  var memorySource = new OC.MemorySource(schema);\r\n  var restSource = new OC.JSONAPISource(schema);\r\n  var localSource = new OC.LocalStorageSource(schema);\r\n\r\n  // Connect MemorySource -> LocalStorageSource (using the default blocking strategy)\r\n  var memToLocalConnector = new Orbit.TransformConnector(memorySource, localSource);\r\n\r\n  // Connect MemorySource <-> JSONAPISource (using the default blocking strategy)\r\n  var memToRestConnector = new Orbit.TransformConnector(memorySource, restSource);\r\n  var restToMemConnector = new Orbit.TransformConnector(restSource, memorySource);\r\n\r\n  // Add a record to the memory source\r\n  memorySource.add('planet', {name: 'Jupiter', classification: 'gas giant'}).then(\r\n    function(planet) {\r\n      console.log('Planet added - ', planet.name, '(id:', planet.id, ')');\r\n    }\r\n  );\r\n\r\n  // Log the transforms in all sources\r\n  memorySource.on('didTransform', function(operation, inverse) {\r\n    console.log('memorySource', operation);\r\n  });\r\n\r\n  localSource.on('didTransform', function(operation, inverse) {\r\n    console.log('localSource', operation);\r\n  });\r\n\r\n  restSource.on('didTransform', function(operation, inverse) {\r\n    console.log('restSource', operation);\r\n  });\r\n\r\n  // CONSOLE OUTPUT\r\n  //\r\n  // memorySource {op: 'add', path: 'planet/1', value: {__id: 1, name: 'Jupiter', classification: 'gas giant'}}\r\n  // localSource  {op: 'add', path: 'planet/1', value: {__id: 1, name: 'Jupiter', classification: 'gas giant'}}\r\n  // restSource   {op: 'add', path: 'planet/1', value: {__id: 1, id: 12345, name: 'Jupiter', classification: 'gas giant'}}\r\n  // memorySource {op: 'add', path: 'planet/1/id', value: 12345}\r\n  // localSource  {op: 'add', path: 'planet/1/id', value: 12345}\r\n  // Planet added - Jupiter (id: 12345)\r\n```\r\n\r\nIn this example, we've created three separate sources and connected them with\r\ntransform connectors that are *blocking*. In other words, the promise returned\r\nfrom an action won't be fulfilled until every event listener that engages with\r\nit (by returning a promise) has been fulfilled.\r\n\r\nIn this case, we're adding a record to the memory source, which the connectors\r\nhelp duplicate in both the REST source and local storage. The REST source returns\r\nan `id` from the server, which is then propagated back to the memory source and\r\nthen the local storage source.\r\n\r\nNote that we could also connect the sources with *non-blocking* connectors with\r\nthe `blocking: false` option:\r\n\r\n```javascript\r\n  // Connect MemorySource -> LocalStorageSource (non-blocking)\r\n  var memToLocalConnector = new Orbit.TransformConnector(memorySource, localSource, {blocking: false});\r\n\r\n  // Connect MemorySource <-> JSONAPISource (non-blocking)\r\n  var memToRestConnector = new Orbit.TransformConnector(memorySource, restSource, {blocking: false});\r\n  var restToMemConnector = new Orbit.TransformConnector(restSource, memorySource, {blocking: false});\r\n```\r\n\r\nIn this case, the promise generated from `memorySource.add` will be resolved\r\nimmediately, after which records will be asynchronously created in the REST\r\nsource and local storage. Any differences, such as an `id` returned from the\r\nserver, will be automatically patched back to the record in the memory source.\r\n\r\n## Interfaces\r\n\r\nThe primary interfaces provided by Orbit are:\r\n\r\n* `Requestable` - for managing requests for data via methods such as `find`,\r\n`create`, `update` and `destroy`.\r\n\r\n* `Transformable` - for keeping data sources in sync through low level\r\ntransformations which follow the JSON PATCH spec detailed in\r\n[RFC 6902](http://tools.ietf.org/html/rfc6902).\r\n\r\nThese interfaces can extend (i.e. be \"mixed into\") your data sources. They can\r\nbe used together or in isolation.\r\n\r\n### Requestable\r\n\r\nThe `Requestable` interface provides a mechanism to define custom \"action\"\r\nmethods on an object or prototype. Actions might typically include `find`,\r\n`add`, `update`, `patch` and `remove`, although the number and names of actions\r\ncan be completely customized.\r\n\r\nThe `Requestable` interface can extend an object or prototype as follows:\r\n\r\n```javascript\r\nvar source = {};\r\nOrbit.Requestable.extend(source);\r\n```\r\n\r\nThis will make your object `Evented` (see below) and create a single action,\r\n`find`, by default. You can also specify alternative actions as follows:\r\n\r\n```javascript\r\nvar source = {};\r\nOrbit.Requestable.extend(source, ['find', 'add', 'update', 'patch', 'remove']);\r\n```\r\n\r\nOr you can add actions later with `Orbit.Requestable.defineAction()`:\r\n\r\n```javascript\r\nvar source = {};\r\nOrbit.Requestable.extend(source); // defines 'find' by default\r\nOrbit.Requestable.defineAction(source, ['add', 'update', 'remove']);\r\nOrbit.Requestable.defineAction(source, 'patch');\r\n```\r\n\r\nIn order to fulfill the contract of an action, define a\r\ndefault \"handler\" method with the name of the action preceded by an underscore\r\n(e.g. `_find`). This handler performs the action and returns a\r\npromise. Here's a simplistic example:\r\n\r\n```javascript\r\nsource._find = function(type, id) {\r\n  return new RSVP.Promise(function(resolve, reject){\r\n    if (source._data[type] && source._data[type][id]) {\r\n      resolve(source._data[type][id]);\r\n    } else {\r\n      reject(type + ' not found');\r\n    }\r\n  });\r\n};\r\n```\r\n\r\nActions combine promise-based return values with an event-driven flow.\r\nEvents can be used to coordinate multiple handlers interested in participating\r\nwith or simply observing the resolution of an action.\r\n\r\nThe following events are associated with an action (`find` in this case):\r\n\r\n* `assistFind` - triggered prior to calling the default `_find` handler.\r\nListeners can optionally return a promise. If any promise resolves\r\nsuccessfully, its resolved value will be used as the return value of\r\n`find`, and no further listeners will called.\r\n\r\n* `rescueFind` -  if `assistFind` and the default `_find` method fail\r\nto resolve, then `rescueFind` will be triggered. Again, listeners can\r\noptionally return a promise. If any promise resolves successfully,\r\nits resolved value will be used as the return value of `find`, and no further\r\nlisteners will called.\r\n\r\n* `didFind` - Triggered upon the successful resolution of the action by any\r\nhandler. Any promises returned by event listeners will be settled in series\r\nbefore proceeding.\r\n\r\n* `didNotFind` - Triggered when an action can't be resolved by any handler.\r\nAny promises returned by event listeners will be settled in series before\r\nproceeding.\r\n\r\nNote that the arguments for actions can be customized for your application.\r\nOrbit will simply pass them through regardless of their number and type. You\r\nwill typically want actions of the same name (e.g. `find`) to accept the same\r\narguments across your data sources.\r\n\r\nLet's take a look at how this could all work:\r\n\r\n```javascript\r\n\r\n// Create some new sources - assume their prototypes are already `Requestable`\r\nvar memorySource = new OC.MemorySource();\r\nvar restSource = new OC.JSONAPISource();\r\nvar localSource = new OC.LocalStorageSource();\r\n\r\n////// Connect the sources via events\r\n\r\n// Check local storage before making a remote call\r\nrestSource.on('assistFind', localSource.find);\r\n\r\n// If the in-memory source can't find the record, query our rest server\r\nmemorySource.on('rescueFind', restSource.find);\r\n\r\n// Audit success / failure\r\nmemorySource.on('didFind', function(type, id, record) {\r\n    audit('find', type, id, true);\r\n});\r\nmemorySource.on('didNotFind', function(type, id, error) {\r\n    audit('find', type, id, false);\r\n});\r\n\r\n////// Perform the action\r\n\r\nmemorySource.find('contact', 1).then(function(contact) {\r\n  // do something with the contact\r\n}, function(error) {\r\n  // there was a problem\r\n});\r\n```\r\n\r\nConfiguration can (and probably should) be done well in advance of actions\r\nbeing called. You essentially want to hook up the wiring between sources and\r\nthen restrict your application's direct access to most of them. This greatly\r\nsimplifies your application code: instead of chaining together a large number\r\nof promises that include multiple sources in every call,\r\nyou can interact with a single source of truth (typically an in-memory data\r\nsource).\r\n\r\n### Transformable\r\n\r\nAlthough the `Requestable` interface can help multiple sources coordinate in\r\nfulfilling a request, it's not sufficient to keep data sources synchronized.\r\nWhen one source fields a request, other sources may need to be notified of\r\nthe precise data changes brought about in that source,\r\nso that they can all stay synchronized. That's where the `Transformable`\r\ninterface comes in...\r\n\r\nThe `Transformable` interface provides a single method, `transform`, which can\r\nbe used to change the contents of a source. Transformations must follow the\r\nJSON PATCH spec detailed in\r\n[RFC 6902](http://tools.ietf.org/html/rfc6902).\r\nThey must specify an operation (`add`, `remove`, or `replace`), a\r\npath, and a value. For instance, the following transformations add, patch and\r\nthen remove a record:\r\n\r\n```javascript\r\n{op: 'add', path: 'planet/1', value: {__id: 1, name: 'Jupiter', classification: 'gas giant'}\r\n{op: 'replace', path: 'planet/1/name', value: 'Earth'}\r\n{op: 'remove', path: 'planet/1'}\r\n```\r\n\r\nThe `Transformable` interface can extend an object or prototype as follows:\r\n\r\n```javascript\r\nvar source = {};\r\nOrbit.Transformable.extend(source);\r\n```\r\n\r\nThis will ensure that your source is `Evented` (see below). It also adds a\r\n`transform` method. In order to fulfill the `transform` method, your source\r\nshould implement a `_transform` method that performs the transform and returns\r\na promise if the transformation is asynchronous.\r\n\r\nIt's important to note that the requested transform may not match the actual\r\ntransform applied to a source. Therefore, each source should call `didTransform`\r\nfor any transforms that actually take place. This method triggers the\r\n`didTransform` event, which returns the operation and an array of inverse\r\noperations.\r\n\r\n`transform` may be called with a single transform operation, or an array of\r\noperations. Any number of `didTransform` events may be triggered as a result.\r\n\r\nTransforms will be queued and performed serially in the order requested.\r\n\r\n## TransformConnector\r\n\r\nA `TransformConnector` watches a transformable source and propagates any\r\ntransforms to a transformable target.\r\n\r\nEach connector is \"one way\", so bi-directional synchronization between sources\r\nrequires the creation of two connectors.\r\n\r\nConnectors can be \"blocking\" or \"non-blocking\". The difference is that\r\n\"blocking\" connectors will return a promise to the `didTransform` event, which\r\nwill prevent the original transform from resolving until the promise itself has\r\nresolved. \"Non-blocking\" transforms do not block the resolution of the original\r\ntransform - asynchronous actions are performed afterward.\r\n\r\nIf the target of a connector is busy processing transformations, then the\r\nconnector will queue operations until the target is free. This ensures that the\r\ntarget's state is as up to date as possible before transformations proceed.\r\n\r\nThe connector's `transform` method actually applies transforms to its target.\r\nThis method attempts to retrieve the current value at the path of the\r\ntransformation and resolves any conflicts with the connector's\r\n`resolveConflicts` method. By default, a simple differential is applied to the\r\ntarget, although both `transform` and `resolveConflicts` can be overridden to\r\napply an alternative differencing algorithm.\r\n\r\n## RequestConnector\r\n\r\nA `RequestConnector` observes requests made to a primary source and allows a\r\nsecondary source to either \"assist\" or \"rescue\" those requests.\r\n\r\nThe `mode` of a `RequestConnector` can be either `\"rescue\"` or `\"assist\"`\r\n(`\"rescue\"` is the default).\r\n\r\nIn `\"rescue\"` mode, the secondary source will only be called upon to fulfill\r\na request if the primary source fails to do so.\r\n\r\nIn `\"assist\"` mode, the secondary source will be called upon to fulfill a\r\nrequest before the primary source. Only if the secondary source fails to\r\nfulfill the request will the primary source be called upon to do so.\r\n\r\nUnlike a `TransformConnector`, a `RequestConnector` always operates in\r\n\"blocking\" mode. In other words, promises are always settled (either succeeding\r\nor failing) before the connector proceeds.\r\n\r\n## Document\r\n\r\n`Document` is a complete implementation of the JSON PATCH spec detailed in\r\n[RFC 6902](http://tools.ietf.org/html/rfc6902).\r\n\r\nIt can be manipulated via a `transform` method that accepts an `operation`, or\r\nwith methods `add`, `remove`, `replace`, `move`, `copy` and `test`.\r\n\r\nData at a particular path can be retrieved from a `Document` with `retrieve()`.\r\n\r\n## Notifications and Events\r\n\r\nOrbit also contains a couple classes for handling notifications and events.\r\nThese will likely be separated into one or more microlibs.\r\n\r\n### Notifier\r\n\r\nThe `Notifier` class can emit messages to an array of subscribed listeners.\r\nHere's a simple example:\r\n\r\n```javascript\r\nvar notifier = new Orbit.Notifier();\r\nnotifier.addListener(function(message) {\r\n  console.log(\"I heard \" + message);\r\n});\r\nnotifier.addListener(function(message) {\r\n  console.log(\"I also heard \" + message);\r\n});\r\n\r\nnotifier.emit('hello'); // logs \"I heard hello\" and \"I also heard hello\"\r\n```\r\n\r\nNotifiers can also poll listeners with an event and return their responses:\r\n\r\n```javascript\r\nvar dailyQuestion = new Orbit.Notifier();\r\ndailyQuestion.addListener(function(question) {\r\n  if (question === 'favorite food?') return 'beer';\r\n});\r\ndailyQuestion.addListener(function(question) {\r\n  if (question === 'favorite food?') return 'wasabi almonds';\r\n});\r\ndailyQuestion.addListener(function(question) {\r\n  // this listener doesn't return anything, and therefore won't participate\r\n  // in the poll\r\n});\r\n\r\ndailyQuestion.poll('favorite food?'); // returns ['beer', 'wasabi almonds']\r\n```\r\n\r\nCalls to `emit` and `poll` will send along all of their arguments.\r\n\r\n### Evented\r\n\r\nThe `Evented` interface uses notifiers to add events to an object. Like\r\nnotifiers, events will send along all of their arguments to subscribed\r\nlisteners.\r\n\r\nThe `Evented` interface can extend an object or prototype as follows:\r\n\r\n```javascript\r\nvar source = {};\r\nOrbit.Evented.extend(source);\r\n```\r\n\r\nListeners can then register themselves for particular events with `on`:\r\n\r\n```javascript\r\nvar listener1 = function(message) {\r\n      console.log('listener1 heard ' + message);\r\n    },\r\n    listener2 = function(message) {\r\n      console.log('listener2 heard ' + message);\r\n    };\r\n\r\nsource.on('greeting', listener1);\r\nsource.on('greeting', listener2);\r\n\r\nevented.emit('greeting', 'hello'); // logs \"listener1 heard hello\" and\r\n                                   //      \"listener2 heard hello\"\r\n```\r\n\r\nListeners can be unregistered from events at any time with `off`:\r\n\r\n```javascript\r\nsource.off('greeting', listener2);\r\n```\r\n\r\nA listener can register itself for multiple events at once:\r\n\r\n```javascript\r\nsource.on('greeting salutation', listener2);\r\n```\r\n\r\nAnd multiple events can be triggered sequentially at once,\r\nassuming that you want to pass them all the same arguments:\r\n\r\n```javascript\r\nsource.emit('greeting salutation', 'hello', 'bonjour', 'guten tag');\r\n```\r\n\r\nLast but not least, listeners can be polled, just like in the notifier example\r\n(note that spaces can't be used in event names):\r\n\r\n```javascript\r\nsource.on('question', function(question) {\r\n  if (question === 'favorite food?') return 'beer';\r\n});\r\n\r\nsource.on('question', function(question) {\r\n  if (question === 'favorite food?') return 'wasabi almonds';\r\n});\r\n\r\nsource.on('question', function(question) {\r\n  // this listener doesn't return anything, and therefore won't participate\r\n  // in the poll\r\n});\r\n\r\nsource.poll('question', 'favorite food?'); // returns ['beer', 'wasabi almonds']\r\n```\r\n\r\n## Contributing\r\n\r\n### Installing Orbit\r\n\r\nInstall the CLI for [Broccoli](https://github.com/broccolijs/broccoli) globally:\r\n\r\n```\r\nnpm install -g broccoli-cli\r\n```\r\n\r\nInstall the rest of Orbit's dependencies:\r\n\r\n```\r\nnpm install\r\n```\r\n\r\n### Building Orbit\r\n\r\nDistributable versions of Orbit can be built to the `/build` directory by\r\nrunning:\r\n\r\n```\r\nnpm run build\r\n```\r\n\r\n### Testing Orbit\r\n\r\n#### CI Testing\r\n\r\nOrbit can be tested in CI mode by running:\r\n\r\n```\r\nnpm test\r\n```\r\n\r\nOr directly with testem (useful for configuring options):\r\n\r\n```\r\ntestem ci\r\n```\r\n\r\n#### Browser Testing\r\n\r\nOrbit can be tested within a browser\r\n(at [http://localhost:4200/tests/](http://localhost:4200/tests/)) by running:\r\n\r\n```\r\nnpm start\r\n```\r\n\r\nOr directly with `broccoli` (useful for configuring the port, etc.):\r\n\r\n```\r\nbroccoli serve\r\n```\r\n\r\n### Generating Documentation\r\n\r\nGenerate docs in the `/docs` directory:\r\n\r\n```\r\nnpm run docs\r\n```\r\n\r\n## License\r\n\r\nCopyright 2014 Cerebris Corporation. MIT License (see LICENSE for details).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}